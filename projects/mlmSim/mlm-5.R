## Paul Johnson
## 2015-08-19


## Generate multi-level model data with "random intercepts"



##' generate 2 level data with (possibly correlated) xbar and b values
##'
##' The defaults set vanilla values for parameters.  They prescribe M
##' balanced groups (n observations each) with no difference between
##' groups.
##' 
##' Suppose a mixed model y = X beta + Z b + e with M groups of
##' observations with n members in each.  The expected value of
##' the predictor x within each unit is xbar and the standard deviation
##' within each unit is xsd.  Each unit is subjected to a random
##' intercept shock, b, for which the expected value is 0 and the
##' standard deviation is bsd.
##'
##' The means of the predictor x within groupings may vary, with or
##' without correlation to the random effects, b.  The expected value
##' of the mean of x within groups is xbarbar and the standard
##' deviation of xbar is xbarsd. The parameter rhobxbar is the
##' correlation "rho" between b and xbar.

##' @param beta A vector of true regression parameters, beta0 and beta1
##' @param xbarbar The expected value of the mean of x.
##' @param xbarsd The standard devisation of the means of x across clusters.
##' 0 means all groups have same center point
##' @param xsd The standard deviation of x within units
##' @param M The number of groupings 
##' @param n The number of lines of data for each grouping. For a
##' balanced design, enter a single number. For an unbalanced design, enter
##' a vector of group sizes. Warning: if M > length(n), the values of n will
##' be recycled. 
##' @param bsd The standard deviation of the intercept shock b
##' @param esd The standard deviation of the error term e.
##' @param rhobxbar The correlation between b and xbar. 0 is assumed in mlm
##' @return A data set.  An attribute "reffects" is included, it is b, the
##' "true random disturbance vector." An attribute beta is also included. 
##' same format as an lme4 raneff object
##' @author Paul Johnson <pauljohn@@ku.edu>
##'
gen3 <- function (beta = c(3, 0.5), M = 10, n = 3, xbarbar = 25,
                  xbarsd = 0, xsd = 4, bsd = 2, esd = 4,
                  rhobxbar = 0.0)
    
{
    if (M < length(n)) stop("There are more elements in n than M")
    rho <- diag(2*M)
    for(j in 1:M){
        rho[j, j+M] <- rho[j+M, j] <- rhobxbar
    }
    sigma <- diag(c(rep(xbarsd, M), rep(bsd, M))) %*% rho %*% diag(c(rep(xbarsd, M), rep(bsd, M)))
    xbarb <- mvrnorm(1, mu = c(rep(xbarbar, M), rep(0, M)), Sigma = sigma)
    xbars <- xbarb[1:M]
    b <- xbarb[(1+M):(2*M)]
    if (length(n) < M) n <- rep(n, length.out = M)
   
    dat <- data.frame(i = unlist(lapply(1:length(n), function(nn) rep(nn, each = n[nn]))) )
    dat$xbar <- unlist(lapply(1:length(n), function(nn) rep(xbars[nn], n[nn])))
    dat$x <- dat$xbar + rnorm(NROW(dat), m = 0, sd = xsd)
    dat$b <- unlist(lapply(1:length(n), function(nn) rep(b[nn], n[nn])))
    dat$ynoe <- beta[1] + beta[2] * dat$x + dat$b
    dat$y <- dat$ynoe + rnorm(NROW(dat), m=0, sd = esd)
    bdf <- data.frame(b)
    colnames(bdf) <- "(Intercept)"
    reffects <- list("i" = bdf)
    class(reffects) <- "ranef.mer"
    attr(dat, "reffects") <- reffects
    attr(dat, "beta") <- beta
    attr(dat, "mc") <- match.call()
    dat
}


##' plot the mlm view of data generated by gen3
##'
##' Creates various scatterplots, showing lines to represent "true y"
##' without error, y including error, and various supplementary lines for
##' fitted models. Plus some cool arrows if you choose ynoe and y =
##' TRUE.
##' 
##' @param fmla An R formula with dv ~ iv
##' @param simdata An output object from gen3. If you supply this, do NOT
##' separately supply data and trueb. Instead, this function will look inside
##' simdata to get what it needs.
##' @param ynoe TRUE or FALSE: Do you want the "true" DV values
##' without the individual level error included? ynoe = contraction of
##' "y no e".
##' @param y TRUE or FALSE: Include the observed DV
##' @param arrows TRUE or FALSE: Can we please draw pretty arrows from
##' ynoe to y for you?
##' @param ols Do you want us to draw an OLS line? If so, set this
##' TRUE, the function calculates a model, and draws it. If you want
##' to calculate your own OLS model, do so, and supply it as the
##' argument here.  either TRUE or FALSE or a fitted lm object:
##' @param mlm Do you want us to draw the estimated BLUP lines from a
##' multi-level model? If so, give argument TRUE, we will run lmer and
##' plot the predicted values. If you want to fit lmer for yourself,
##' supply the fitted model for this argument and we will draw the
##' lines it calls for.
##' @param ...
##' @param data Data set (the "data" component in gen3 output or
##' compatible). Must have variable i indexing the groups. This argument
##' is included here separately for special purposes, I don't expect
##' most users need it.
##' @param trueb Will be extracted from the simdata object if you
##' supply one. Otherwise, this should be a vector of true random
##' intercepts. It is required to plot the "true" group regression
##' lines, so if you don't supply simdata, you have to supply this.
##' @param beta A vector with the intercept and slope. It is
##' needed to plot the "true" group regression lines.  If you don't
##' supply simdata, you have to supply this.
##' @return a list that may be empty, except when ols = TRUE or mlm =
##' TRUE. In those cases, the fitted ols or mlm models will be
##' returned in the list.
##' @author Paul Johnson
##' 
plotLines <- function(fmla, data = NULL, ynoe = TRUE, y = FALSE,
                      arrows = y & ynoe, ols = FALSE, mlm = FALSE, ...,
                      trueb = TRUE, beta)
{
    dotargs <- list(...)
    dv <- as.character(fmla[[2]])
    iv <- as.character(fmla[[3]])

    parms <- list(ylim = magRange(data[ , dv], 1.3))
    ivmean <- mean(data[ , iv], na.rm = TRUE)
   
    ## any dot arguments for par OK, some for plot OK
    legalParms <- unique(c(names(par()), "xlim", "ylim", "main", "xlab", "ylab", "axes"))  

    parms <- modifyList(parms, dotargs[which(names(dotargs) %in% legalParms)] )
    parms <- modifyList(list(fmla, type = "n", data = data), parms) 
    do.call("plot", parms)
    
    lineLegend <- list(legend = c(), lwd = c(), col = c())

    if (isTRUE(trueb) || is.numeric(trueb)) {
        if (missing(beta)) {
            ## Try to retrieve attribute from data frame
            beta <- try(attr(data, "beta"))
            if (is.null(beta)) warning(paste("Sorry, you must supply beta",
                          " (so we can get the intercept and slope)"))
        }
        if (isTRUE(trueb)) trueb <- attr(data, "reffects")[["i"]][ , "(Intercept)"]
        M <- length(trueb)
        for(mm in 1:M) {
            abline(a = beta[1] + trueb[mm], b = beta[2], lty = mm, col = "gray70")
        }
        lineLegend$legend <- c(lineLegend$legend, "True Model")
        lineLegend$lwd <- c(lineLegend$lwd, 1)
        lineLegend$col <- c(lineLegend$col, "gray70")
    }
    
    
    pointLegend <- list(legend = c(), pch = c(), col = c())
    if (ynoe) {
        mycol <- if (y) "gray80" else "black"
        points(ynoe ~ x, data = data, col = mycol, pch = 1)
        pointLegend$legend <- c(pointLegend$legend, "without e")
        pointLegend$col <- c(pointLegend$col, mycol)
        pointLegend$pch <- c(pointLegend$pch, 1)
    }
    if (y){
        points(y ~ x, data = data, col = "blue", pch = 1)
        pointLegend$legend <- c(pointLegend$legend, "observed")
        pointLegend$col <- c(pointLegend$col, "blue")
        pointLegend$pch <- c(pointLegend$pch, 1)
    }
    if (arrows){
        arrows(data[ ,iv], data$ynoe + 0.2 * (data$y - data$ynoe) ,
               data$x, data$y - 0.2*(data$y - data$ynoe), lty = 4, length = 0.05)
    }

    res <- list()
    
    if (ols){
        if (! inherits(ols, "lm"))
            m1 <- lm(fmla, data = data)
        abline(m1, col = "blue", lwd = 1.5)
        lineLegend$legend <- c(lineLegend$legend, "OLS (fitted)")
        lineLegend$lwd <- c(lineLegend$lwd, 2)
        lineLegend$col <- c(lineLegend$col, "blue")
        res$ols <- m1
    }
    if (mlm){
        if (!inherits(mlm, "merMod"))
            mlm1 <- lmer(as.formula(paste(deparse(fmla), "+ (1|i)")), data = data)
        mlm1ab <- coef(mlm1)$i
        for(mm in 1:NROW(mlm1ab)) abline(mlm1ab[mm, 1], mlm1ab[mm, 2], col = "red", lty = mm)
        lineLegend$legend <- c(lineLegend$legend, "MLM (blups)")
        lineLegend$lwd <- c(lineLegend$lwd, 1)
        lineLegend$col <- c(lineLegend$col, "red")
        res$mlm <- mlm1
    }
    if (length(lineLegend$legend > 0)) legend("topleft", legend = lineLegend$legend, lwd = lineLegend$lwd, col = lineLegend$col)

    if (length(pointLegend$legend > 0)) legend("topright", legend = pointLegend$legend, pch = pointLegend$pch, col = pointLegend$col, title = "DV")
    
    invisible(res)
}


##' Creates a battery of plots to display regression with random intercepts
##' 
##' This creates 2 plots, an ordinary scatterplot and a 2x2 depiction of
##' 4 plots I want to show students
##' 
##' @param data 
##' @param trueb 
##' @return this creates plots. 
##' @author Paul Johnson
plotSim <- function(fmla, data = NULL) {
    plotLines(fmla, data, y = TRUE, ynoe = FALSE, trueb = FALSE,
              arrows = FALSE, main = "Observed Scatter")
    ##dev.new(height = 8, widht = 7)
    op <- par(no.readonly = TRUE)
    par(mfrow = c(2,2))
    par(mar = c(4,4,2,2) + 0.1)
    
    plotLines(fmla, data, ynoe = TRUE, main = "True Group Lines")
    
    plotLines(fmla, data, y = TRUE, ynoe = TRUE, trueb = TRUE,  main = "Scatter Observed y")
    
    plotLines(fmla, data, y = TRUE, ols = TRUE, main = "Superimpose OLS Fit")

    plotLines(fmla, data, y = TRUE, ynoe = FALSE,  ols = TRUE,
              mlm = TRUE, main = "MLM predictions for the Groups")
    par(op)
    
}

library(lme4)
library(lattice)
library(rockchalk)

M <- 10; beta0 <- 3; beta1 <- 0.5;

simdata <- gen3(M = M, beta = c(beta0, beta1),
                bsd = 20, xbarsd = 1, xsd = 20,
                esd = 14, rhobxbar = 0.0)

## Uses dotplot.ranef.mer from lme4 & lattice

dotplot(attr(simdata, "reffects"))

## What can plotLines do to visualize that?

plotLines(y ~ x, data = simdata, y = TRUE, ynoe = FALSE,
          main =  "Observed Scatter", trueb = FALSE)

plotLines(y ~ x, data = simdata, y = FALSE, ynoe = TRUE, 
          main = "No e in y!")

plotLines(y ~ x, data = simdata, y = TRUE, ynoe = TRUE, 
          main = "Scatter Above/Below Group Lines")

## If you hate arrows (Gosh, why?)
plotLines(y ~ x, data = simdata, y = TRUE, ynoe = TRUE, 
          arrows = FALSE, main = "Scatter Above/Below Group Lines")

plotLines(y ~ x, data = simdata, y = TRUE, ynoe = FALSE, 
          ols = TRUE, main = "Superimpose OLS Fit")

plotLines(y ~ x, data = simdata, y = TRUE, ynoe = FALSE, ols = TRUE,
          mlm = TRUE, main = "MLM predictions for the Groups")


## I got tired of running those over and over, so boiled down
## to plotSim. This
## creates a scatterplot and a 2x2 layout
plotSim(y ~ x, data = simdata)


## With high correlation b/t xbar and b, and just a few observations
## in each group, fitted models don't get beta1 correct.
simdata <- gen3(M = 5, n = 3, beta = c(beta0, beta1), bsd = 20,
                xbarsd = 20, esd = 14, rhobxbar = 0.8)

plotSim(y ~ x, simdata)


## Do same with more observations per group, perhaps not so
## discouraging for MLM. I've tested this quite a bit. You can
## draw samples in which MLM and OLS are both fooled badly about
## beta1.  If you run this 20 times, I bet you'll get your own
## theory.
simdata <- gen3(M = 5, n = 20, beta = c(beta0, beta1), bsd = 20,
                xbarsd = 140, esd = 14, rhobxbar = 0.80)

plotSim(y ~ x, simdata)

## My current guess is that the realized correlation between
## x and b is driving this.  May get a student to simulate it.

simdata <- gen3(M = 55, n = 10, beta = c(beta0, beta1), bsd = 20,
                xbarsd = 20, esd = 14, rhobxbar = 0.8)

plotSim(y ~ x, simdata)


## Fiddle with arguments
simdata <- gen3(M = M, n = 10, beta = c(beta0, beta1), bsd = 20, xbarsd = 5,
                xsd = 11, esd = 14, rhobxbar = 0.5)

plotSim(y ~ x, simdata)

simdata <- gen3(M = M,
                n = c(10, 20, 5, 3, 40, 10, 20, 30, 40, 50),
                beta = c(beta0, beta1), bsd = 20, xbarsd = 10,
                xsd = 21,  esd = 14, rhobxbar = 0.7)
plotSim(y ~ x, simdata)


simdata <- gen3(M = M, n = c(4, 2, 3, 4, 6, 8),
                beta = c(beta0, beta1), bsd = 20,
                xbarsd = 10, esd = 14, rhobxbar = 0.0)

plot(y ~ x, simdata)

plotSim(y ~ x, simdata)
